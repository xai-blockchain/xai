<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secure Storage Test Suite</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
      border-bottom: 3px solid #2196f3;
      padding-bottom: 10px;
    }
    .test-section {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .test-case {
      margin: 15px 0;
      padding: 15px;
      border-left: 4px solid #ddd;
      background: #f9f9f9;
    }
    .test-case.pass {
      border-left-color: #4caf50;
      background: #e8f5e9;
    }
    .test-case.fail {
      border-left-color: #f44336;
      background: #ffebee;
    }
    .test-case h3 {
      margin-top: 0;
      color: #333;
    }
    .test-result {
      font-weight: bold;
      margin: 10px 0;
    }
    .test-result.pass {
      color: #4caf50;
    }
    .test-result.fail {
      color: #f44336;
    }
    button {
      background: #2196f3;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
    }
    button:hover {
      background: #1976d2;
    }
    .summary {
      background: #333;
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin-top: 30px;
    }
    .summary h2 {
      margin-top: 0;
    }
    .stats {
      display: flex;
      gap: 30px;
      margin-top: 15px;
    }
    .stat {
      font-size: 24px;
      font-weight: bold;
    }
    .stat.pass {
      color: #4caf50;
    }
    .stat.fail {
      color: #f44336;
    }
    pre {
      background: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 12px;
    }
    .error {
      color: #f44336;
      font-family: monospace;
      font-size: 13px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>XAI Browser Wallet - Secure Storage Test Suite</h1>

  <div class="test-section">
    <h2>Test Controls</h2>
    <button onclick="runAllTests()">Run All Tests</button>
    <button onclick="clearResults()">Clear Results</button>
    <button onclick="clearStorage()">Clear Storage</button>
  </div>

  <div id="results"></div>

  <div class="summary" id="summary" style="display:none;">
    <h2>Test Summary</h2>
    <div class="stats">
      <div>Total: <span class="stat" id="totalTests">0</span></div>
      <div>Passed: <span class="stat pass" id="passedTests">0</span></div>
      <div>Failed: <span class="stat fail" id="failedTests">0</span></div>
    </div>
  </div>

  <script>
    // Mock chrome.storage.local API for testing
    const mockStorage = {};
    const chrome = {
      storage: {
        local: {
          set: (items, callback) => {
            Object.assign(mockStorage, items);
            if (callback) callback();
            return Promise.resolve();
          },
          get: (keys, callback) => {
            const result = {};
            const keyArray = Array.isArray(keys) ? keys : [keys];
            keyArray.forEach(key => {
              if (mockStorage[key] !== undefined) {
                result[key] = mockStorage[key];
              }
            });
            if (callback) callback(result);
            return Promise.resolve(result);
          },
          remove: (keys, callback) => {
            const keyArray = Array.isArray(keys) ? keys : [keys];
            keyArray.forEach(key => delete mockStorage[key]);
            if (callback) callback();
            return Promise.resolve();
          },
          clear: (callback) => {
            Object.keys(mockStorage).forEach(key => delete mockStorage[key]);
            if (callback) callback();
            return Promise.resolve();
          }
        }
      }
    };

    // Make chrome available globally
    window.chrome = chrome;
  </script>

  <!-- Load secure storage module -->
  <script src="../../../src/xai/browser_wallet_extension/secure-storage.js"></script>

  <script>
    let testResults = [];
    let passCount = 0;
    let failCount = 0;

    function clearResults() {
      testResults = [];
      passCount = 0;
      failCount = 0;
      document.getElementById('results').innerHTML = '';
      document.getElementById('summary').style.display = 'none';
    }

    function clearStorage() {
      Object.keys(mockStorage).forEach(key => delete mockStorage[key]);
      console.log('Storage cleared');
    }

    async function runAllTests() {
      clearResults();

      const tests = [
        // Basic Encryption Tests
        testEncryptDecrypt,
        testEncryptionUniqueness,
        testPasswordValidation,

        // Storage Tests
        testStorageSetGet,
        testStorageRemove,
        testMultipleValues,

        // Lock/Unlock Tests
        testLockUnlock,
        testWrongPassword,
        testAutoLock,

        // Migration Tests
        testPlaintextMigration,
        testPartialMigration,

        // Password Management
        testPasswordChange,
        testDisableEncryption,

        // Edge Cases
        testEmptyStorage,
        testCorruptedData,
        testSpecialCharactersInPassword,
        testLargeData,

        // Security Tests
        testTamperDetection,
        testIVUniqueness,
        testSaltUniqueness
      ];

      for (const test of tests) {
        try {
          await test();
        } catch (error) {
          logTest(test.name, false, `Unhandled error: ${error.message}`);
        }
      }

      showSummary();
    }

    function logTest(name, passed, details = '') {
      testResults.push({ name, passed, details });

      if (passed) {
        passCount++;
      } else {
        failCount++;
      }

      const resultsDiv = document.getElementById('results');
      const testDiv = document.createElement('div');
      testDiv.className = `test-case ${passed ? 'pass' : 'fail'}`;
      testDiv.innerHTML = `
        <h3>${name}</h3>
        <div class="test-result ${passed ? 'pass' : 'fail'}">
          ${passed ? '✓ PASS' : '✗ FAIL'}
        </div>
        ${details ? `<div class="error">${details}</div>` : ''}
      `;
      resultsDiv.appendChild(testDiv);
    }

    function showSummary() {
      document.getElementById('summary').style.display = 'block';
      document.getElementById('totalTests').textContent = testResults.length;
      document.getElementById('passedTests').textContent = passCount;
      document.getElementById('failedTests').textContent = failCount;
    }

    // ====================
    // TEST CASES
    // ====================

    async function testEncryptDecrypt() {
      try {
        const password = 'testPassword123';
        const testData = { secret: 'mySecretValue', token: 'abc123' };

        // Import encryption functions from secure-storage.js
        // They're not exported, so we'll access them via the global scope
        const encrypted = await encryptData(testData, password);
        const decrypted = await decryptData(encrypted, password);

        const passed = JSON.stringify(decrypted) === JSON.stringify(testData);
        logTest('Basic Encrypt/Decrypt', passed,
          passed ? '' : `Expected ${JSON.stringify(testData)}, got ${JSON.stringify(decrypted)}`);
      } catch (error) {
        logTest('Basic Encrypt/Decrypt', false, error.message);
      }
    }

    async function testEncryptionUniqueness() {
      try {
        const password = 'testPassword123';
        const testData = { value: 'same data' };

        const encrypted1 = await encryptData(testData, password);
        const encrypted2 = await encryptData(testData, password);

        const passed = encrypted1 !== encrypted2;
        logTest('Encryption Uniqueness (Salt/IV)', passed,
          passed ? '' : 'Same data encrypted twice produced identical ciphertext (IV/salt not unique)');
      } catch (error) {
        logTest('Encryption Uniqueness (Salt/IV)', false, error.message);
      }
    }

    async function testPasswordValidation() {
      try {
        const storage = new SecureStorage();

        let errorThrown = false;
        try {
          await storage.enableEncryption('short');
        } catch (error) {
          errorThrown = error.message.includes('at least 8');
        }

        logTest('Password Validation', errorThrown,
          errorThrown ? '' : 'Short password was accepted');
      } catch (error) {
        logTest('Password Validation', false, error.message);
      }
    }

    async function testStorageSetGet() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword123');

        await storage.set('testKey', 'testValue');
        const retrieved = await storage.get('testKey');

        const passed = retrieved === 'testValue';
        logTest('Storage Set/Get', passed,
          passed ? '' : `Expected "testValue", got "${retrieved}"`);
      } catch (error) {
        logTest('Storage Set/Get', false, error.message);
      }
    }

    async function testStorageRemove() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword123');

        await storage.set('testKey', 'testValue');
        await storage.remove('testKey');
        const retrieved = await storage.get('testKey');

        const passed = retrieved === null;
        logTest('Storage Remove', passed,
          passed ? '' : `Expected null after remove, got "${retrieved}"`);
      } catch (error) {
        logTest('Storage Remove', false, error.message);
      }
    }

    async function testMultipleValues() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword123');

        const testData = {
          key1: 'value1',
          key2: { nested: 'object' },
          key3: [1, 2, 3],
          key4: 12345
        };

        for (const [key, value] of Object.entries(testData)) {
          await storage.set(key, value);
        }

        let allMatch = true;
        for (const [key, expectedValue] of Object.entries(testData)) {
          const retrieved = await storage.get(key);
          if (JSON.stringify(retrieved) !== JSON.stringify(expectedValue)) {
            allMatch = false;
            break;
          }
        }

        logTest('Multiple Values Storage', allMatch,
          allMatch ? '' : 'Some values did not match after storage');
      } catch (error) {
        logTest('Multiple Values Storage', false, error.message);
      }
    }

    async function testLockUnlock() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword123');

        await storage.set('testKey', 'testValue');

        storage.lock();
        const isLocked = storage.isStorageLocked();

        await storage.unlock('testPassword123');
        const isUnlocked = !storage.isStorageLocked();

        const retrieved = await storage.get('testKey');

        const passed = isLocked && isUnlocked && retrieved === 'testValue';
        logTest('Lock/Unlock', passed,
          passed ? '' : 'Lock/unlock cycle failed');
      } catch (error) {
        logTest('Lock/Unlock', false, error.message);
      }
    }

    async function testWrongPassword() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('correctPassword');

        await storage.set('testKey', 'testValue');
        storage.lock();

        const unlocked = await storage.unlock('wrongPassword');

        const passed = !unlocked;
        logTest('Wrong Password Rejection', passed,
          passed ? '' : 'Wrong password was accepted');
      } catch (error) {
        logTest('Wrong Password Rejection', false, error.message);
      }
    }

    async function testAutoLock() {
      clearStorage();

      try {
        // This would require waiting 15 minutes, so we'll test the timer setup
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword123');

        const hasTimer = storage.autoLockTimer !== null;

        logTest('Auto-Lock Timer Setup', hasTimer,
          hasTimer ? '' : 'Auto-lock timer not initialized');
      } catch (error) {
        logTest('Auto-Lock Timer Setup', false, error.message);
      }
    }

    async function testPlaintextMigration() {
      clearStorage();

      try {
        // Set up plaintext data
        await chrome.storage.local.set({
          'walletSessionToken': 'token123',
          'walletSessionSecret': 'secret456',
          'personalAiApiKey': 'sk-ant-789'
        });

        const storage = new SecureStorage();
        await storage.enableEncryption('migrationPassword');

        // Check plaintext deleted
        const oldData = await chrome.storage.local.get(['walletSessionToken']);
        const plaintextDeleted = !oldData.walletSessionToken;

        // Check encrypted data exists
        const encryptedData = await chrome.storage.local.get(['_encrypted_walletSessionToken']);
        const encryptedExists = !!encryptedData._encrypted_walletSessionToken;

        // Check can decrypt
        const retrieved = await storage.get('walletSessionToken');
        const decryptionWorks = retrieved === 'token123';

        const passed = plaintextDeleted && encryptedExists && decryptionWorks;
        logTest('Plaintext Migration', passed,
          passed ? '' : 'Migration did not properly encrypt and delete plaintext');
      } catch (error) {
        logTest('Plaintext Migration', false, error.message);
      }
    }

    async function testPartialMigration() {
      clearStorage();

      try {
        // Set up partial plaintext data (some keys missing)
        await chrome.storage.local.set({
          'walletSessionToken': 'token123'
          // Other keys missing
        });

        const storage = new SecureStorage();
        await storage.enableEncryption('migrationPassword');

        // Should not throw error
        const retrieved = await storage.get('walletSessionToken');
        const missingKey = await storage.get('walletSessionSecret');

        const passed = retrieved === 'token123' && missingKey === null;
        logTest('Partial Migration', passed,
          passed ? '' : 'Failed to handle partial plaintext data');
      } catch (error) {
        logTest('Partial Migration', false, error.message);
      }
    }

    async function testPasswordChange() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('oldPassword');

        await storage.set('testKey', 'testValue');

        const changed = await storage.changePassword('oldPassword', 'newPassword123');

        if (changed) {
          storage.lock();
          await storage.unlock('newPassword123');
          const retrieved = await storage.get('testKey');

          const passed = retrieved === 'testValue';
          logTest('Password Change', passed,
            passed ? '' : 'Data not accessible after password change');
        } else {
          logTest('Password Change', false, 'Password change failed');
        }
      } catch (error) {
        logTest('Password Change', false, error.message);
      }
    }

    async function testDisableEncryption() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword');

        await storage.set('testKey', 'testValue');

        await storage.disableEncryption('testPassword');

        // Check plaintext restored
        const plaintext = await chrome.storage.local.get(['testKey']);
        const passed = plaintext.testKey === 'testValue';

        logTest('Disable Encryption', passed,
          passed ? '' : 'Plaintext not restored after disabling encryption');
      } catch (error) {
        logTest('Disable Encryption', false, error.message);
      }
    }

    async function testEmptyStorage() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword');

        const retrieved = await storage.get('nonExistentKey');

        const passed = retrieved === null;
        logTest('Empty Storage Handling', passed,
          passed ? '' : 'Expected null for non-existent key');
      } catch (error) {
        logTest('Empty Storage Handling', false, error.message);
      }
    }

    async function testCorruptedData() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword');

        // Manually insert corrupted data
        await chrome.storage.local.set({
          '_encrypted_testKey': 'notValidBase64Data!@#$'
        });

        let errorThrown = false;
        try {
          await storage.get('testKey');
        } catch (error) {
          errorThrown = true;
        }

        logTest('Corrupted Data Handling', errorThrown,
          errorThrown ? '' : 'Corrupted data did not throw error');
      } catch (error) {
        logTest('Corrupted Data Handling', false, error.message);
      }
    }

    async function testSpecialCharactersInPassword() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        const password = 'p@$$w0rd!#%&*(){}[]<>?/|\\';

        await storage.enableEncryption(password);
        await storage.set('testKey', 'testValue');

        storage.lock();
        await storage.unlock(password);
        const retrieved = await storage.get('testKey');

        const passed = retrieved === 'testValue';
        logTest('Special Characters in Password', passed,
          passed ? '' : 'Special characters in password caused failure');
      } catch (error) {
        logTest('Special Characters in Password', false, error.message);
      }
    }

    async function testLargeData() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword');

        // Create large object (~1KB)
        const largeData = {
          array: new Array(100).fill('x'.repeat(10)),
          nested: {
            deep: {
              structure: {
                with: {
                  many: {
                    levels: 'value'
                  }
                }
              }
            }
          }
        };

        await storage.set('largeKey', largeData);
        const retrieved = await storage.get('largeKey');

        const passed = JSON.stringify(retrieved) === JSON.stringify(largeData);
        logTest('Large Data Encryption', passed,
          passed ? '' : 'Large data did not match after encryption');
      } catch (error) {
        logTest('Large Data Encryption', false, error.message);
      }
    }

    async function testTamperDetection() {
      clearStorage();

      try {
        const storage = new SecureStorage();
        await storage.enableEncryption('testPassword');

        await storage.set('testKey', 'testValue');

        // Get encrypted data
        const encrypted = await chrome.storage.local.get(['_encrypted_testKey']);
        const encryptedBytes = Uint8Array.from(atob(encrypted._encrypted_testKey), c => c.charCodeAt(0));

        // Tamper with ciphertext (flip a bit)
        encryptedBytes[30] ^= 0xFF;

        // Store tampered data
        const tamperedBase64 = btoa(String.fromCharCode(...encryptedBytes));
        await chrome.storage.local.set({ '_encrypted_testKey': tamperedBase64 });

        // Try to decrypt
        let errorThrown = false;
        try {
          await storage.get('testKey');
        } catch (error) {
          errorThrown = error.message.includes('Decryption failed');
        }

        logTest('Tamper Detection (GCM Auth)', errorThrown,
          errorThrown ? '' : 'Tampered data was not detected');
      } catch (error) {
        logTest('Tamper Detection (GCM Auth)', false, error.message);
      }
    }

    async function testIVUniqueness() {
      try {
        const password = 'testPassword';
        const data = { value: 'test' };

        // Encrypt same data 10 times
        const encrypted = [];
        for (let i = 0; i < 10; i++) {
          encrypted.push(await encryptData(data, password));
        }

        // Extract IVs (bytes 16-27 after base64 decode)
        const ivs = encrypted.map(enc => {
          const bytes = Uint8Array.from(atob(enc), c => c.charCodeAt(0));
          return Array.from(bytes.slice(16, 28)).join(',');
        });

        // Check all unique
        const uniqueIvs = new Set(ivs);
        const passed = uniqueIvs.size === ivs.length;

        logTest('IV Uniqueness', passed,
          passed ? '' : `Found ${ivs.length - uniqueIvs.size} duplicate IVs`);
      } catch (error) {
        logTest('IV Uniqueness', false, error.message);
      }
    }

    async function testSaltUniqueness() {
      try {
        const password = 'testPassword';
        const data = { value: 'test' };

        // Encrypt same data 10 times
        const encrypted = [];
        for (let i = 0; i < 10; i++) {
          encrypted.push(await encryptData(data, password));
        }

        // Extract salts (first 16 bytes after base64 decode)
        const salts = encrypted.map(enc => {
          const bytes = Uint8Array.from(atob(enc), c => c.charCodeAt(0));
          return Array.from(bytes.slice(0, 16)).join(',');
        });

        // Check all unique
        const uniqueSalts = new Set(salts);
        const passed = uniqueSalts.size === salts.length;

        logTest('Salt Uniqueness', passed,
          passed ? '' : `Found ${salts.length - uniqueSalts.size} duplicate salts`);
      } catch (error) {
        logTest('Salt Uniqueness', false, error.message);
      }
    }
  </script>
</body>
</html>
