"""
AIXN Blockchain Node - Full node implementation
Runs blockchain, mines blocks, handles transactions, P2P communication
"""

import json
import time
import threading
import requests
from flask import Flask, jsonify, request
from flask_cors import CORS
from blockchain import Blockchain, Transaction
from wallet import Wallet
import sys

class BlockchainNode:
    """Full blockchain node with mining and networking"""

    def __init__(self, host='0.0.0.0', port=8545, miner_address=None):
        self.host = host
        self.port = port
        self.blockchain = Blockchain()
        self.peers = set()  # Connected peer nodes
        self.is_mining = False
        self.mining_thread = None

        # Set up miner wallet
        if miner_address:
            self.miner_address = miner_address
        else:
            # Create default miner wallet
            miner_wallet = Wallet()
            self.miner_address = miner_wallet.address
            print(f"Miner Address: {self.miner_address}")

        # Flask app for API
        self.app = Flask(__name__)
        CORS(self.app)
        self.setup_routes()

    def setup_routes(self):
        """Setup API endpoints"""

        @self.app.route('/', methods=['GET'])
        def index():
            return jsonify({
                'status': 'online',
                'node': 'AIXN Full Node',
                'version': '1.0.0',
                'endpoints': {
                    '/stats': 'GET - Blockchain statistics',
                    '/blocks': 'GET - All blocks',
                    '/blocks/<index>': 'GET - Specific block',
                    '/transactions': 'GET - Pending transactions',
                    '/transaction/<txid>': 'GET - Transaction details',
                    '/balance/<address>': 'GET - Address balance',
                    '/history/<address>': 'GET - Transaction history',
                    '/send': 'POST - Send transaction',
                    '/mine': 'POST - Mine pending transactions',
                    '/peers': 'GET - Connected peers',
                    '/sync': 'POST - Sync with network'
                }
            })

        @self.app.route('/stats', methods=['GET'])
        def get_stats():
            """Get blockchain statistics"""
            stats = self.blockchain.get_stats()
            stats['miner_address'] = self.miner_address
            stats['peers'] = len(self.peers)
            stats['is_mining'] = self.is_mining
            stats['node_uptime'] = time.time() - self.start_time

            return jsonify(stats)

        @self.app.route('/blocks', methods=['GET'])
        def get_blocks():
            """Get all blocks"""
            limit = request.args.get('limit', default=10, type=int)
            offset = request.args.get('offset', default=0, type=int)

            blocks = [block.to_dict() for block in self.blockchain.chain]
            blocks.reverse()  # Most recent first

            return jsonify({
                'total': len(blocks),
                'limit': limit,
                'offset': offset,
                'blocks': blocks[offset:offset+limit]
            })

        @self.app.route('/blocks/<int:index>', methods=['GET'])
        def get_block(index):
            """Get specific block"""
            if index < 0 or index >= len(self.blockchain.chain):
                return jsonify({'error': 'Block not found'}), 404

            return jsonify(self.blockchain.chain[index].to_dict())

        @self.app.route('/transactions', methods=['GET'])
        def get_pending_transactions():
            """Get pending transactions"""
            return jsonify({
                'count': len(self.blockchain.pending_transactions),
                'transactions': [tx.to_dict() for tx in self.blockchain.pending_transactions]
            })

        @self.app.route('/transaction/<txid>', methods=['GET'])
        def get_transaction(txid):
            """Get transaction by ID"""
            for block in self.blockchain.chain:
                for tx in block.transactions:
                    if tx.txid == txid:
                        return jsonify({
                            'found': True,
                            'block': block.index,
                            'confirmations': len(self.blockchain.chain) - block.index,
                            'transaction': tx.to_dict()
                        })

            # Check pending
            for tx in self.blockchain.pending_transactions:
                if tx.txid == txid:
                    return jsonify({
                        'found': True,
                        'status': 'pending',
                        'transaction': tx.to_dict()
                    })

            return jsonify({'found': False, 'error': 'Transaction not found'}), 404

        @self.app.route('/balance/<address>', methods=['GET'])
        def get_balance(address):
            """Get address balance"""
            balance = self.blockchain.get_balance(address)
            return jsonify({
                'address': address,
                'balance': balance
            })

        @self.app.route('/history/<address>', methods=['GET'])
        def get_history(address):
            """Get transaction history for address"""
            history = self.blockchain.get_transaction_history(address)
            return jsonify({
                'address': address,
                'transaction_count': len(history),
                'transactions': history
            })

        @self.app.route('/send', methods=['POST'])
        def send_transaction():
            """Submit new transaction"""
            data = request.json

            required_fields = ['sender', 'recipient', 'amount', 'private_key']
            if not all(field in data for field in required_fields):
                return jsonify({'error': 'Missing required fields'}), 400

            try:
                # Derive public key from private key
                import ecdsa
                sk = ecdsa.SigningKey.from_string(bytes.fromhex(data['private_key']), curve=ecdsa.SECP256k1)
                vk = sk.get_verifying_key()
                public_key = vk.to_string().hex()

                # Create transaction with public key
                tx = Transaction(
                    sender=data['sender'],
                    recipient=data['recipient'],
                    amount=float(data['amount']),
                    fee=float(data.get('fee', 0.01)),
                    public_key=public_key
                )

                # Sign transaction
                tx.sign_transaction(data['private_key'])

                # Add to blockchain
                if self.blockchain.add_transaction(tx):
                    # Broadcast to peers
                    self.broadcast_transaction(tx)

                    return jsonify({
                        'success': True,
                        'txid': tx.txid,
                        'message': 'Transaction submitted successfully'
                    })
                else:
                    return jsonify({
                        'success': False,
                        'error': 'Transaction validation failed'
                    }), 400

            except Exception as e:
                return jsonify({'error': str(e)}), 500

        @self.app.route('/mine', methods=['POST'])
        def mine_block():
            """Mine pending transactions"""
            if not self.blockchain.pending_transactions:
                return jsonify({'error': 'No pending transactions to mine'}), 400

            try:
                block = self.blockchain.mine_pending_transactions(self.miner_address)

                # Broadcast new block to peers
                self.broadcast_block(block)

                return jsonify({
                    'success': True,
                    'block': block.to_dict(),
                    'message': f'Block {block.index} mined successfully',
                    'reward': self.blockchain.block_reward
                })

            except Exception as e:
                return jsonify({'error': str(e)}), 500

        @self.app.route('/auto-mine/start', methods=['POST'])
        def start_auto_mining():
            """Start automatic mining"""
            if self.is_mining:
                return jsonify({'message': 'Mining already active'})

            self.start_mining()
            return jsonify({'message': 'Auto-mining started'})

        @self.app.route('/auto-mine/stop', methods=['POST'])
        def stop_auto_mining():
            """Stop automatic mining"""
            if not self.is_mining:
                return jsonify({'message': 'Mining not active'})

            self.stop_mining()
            return jsonify({'message': 'Auto-mining stopped'})

        @self.app.route('/peers', methods=['GET'])
        def get_peers():
            """Get connected peers"""
            return jsonify({
                'count': len(self.peers),
                'peers': list(self.peers)
            })

        @self.app.route('/peers/add', methods=['POST'])
        def add_peer():
            """Add peer node"""
            data = request.json
            if 'url' not in data:
                return jsonify({'error': 'Missing peer URL'}), 400

            self.add_peer(data['url'])
            return jsonify({'message': f'Peer {data["url"]} added'})

        @self.app.route('/sync', methods=['POST'])
        def sync_blockchain():
            """Synchronize blockchain with peers"""
            synced = self.sync_with_network()
            return jsonify({
                'synced': synced,
                'chain_length': len(self.blockchain.chain)
            })

    def start_mining(self):
        """Start automatic mining in background thread"""
        self.is_mining = True
        self.mining_thread = threading.Thread(target=self._mine_continuously, daemon=True)
        self.mining_thread.start()
        print("⛏️  Auto-mining started")

    def stop_mining(self):
        """Stop automatic mining"""
        self.is_mining = False
        if self.mining_thread:
            self.mining_thread.join(timeout=5)
        print("⏸️  Auto-mining stopped")

    def _mine_continuously(self):
        """Continuously mine blocks"""
        while self.is_mining:
            if self.blockchain.pending_transactions:
                print(f"Mining block with {len(self.blockchain.pending_transactions)} transactions...")
                block = self.blockchain.mine_pending_transactions(self.miner_address)
                print(f"✅ Block {block.index} mined! Hash: {block.hash}")

                # Broadcast to peers
                self.broadcast_block(block)

            time.sleep(1)  # Small delay between mining attempts

    def add_peer(self, peer_url: str):
        """Add peer node"""
        if peer_url not in self.peers:
            self.peers.add(peer_url)
            print(f"Added peer: {peer_url}")

    def broadcast_transaction(self, transaction: Transaction):
        """Broadcast transaction to all peers"""
        for peer in self.peers:
            try:
                requests.post(
                    f"{peer}/transaction/receive",
                    json=transaction.to_dict(),
                    timeout=2
                )
            except:
                pass

    def broadcast_block(self, block):
        """Broadcast new block to all peers"""
        for peer in self.peers:
            try:
                requests.post(
                    f"{peer}/block/receive",
                    json=block.to_dict(),
                    timeout=2
                )
            except:
                pass

    def sync_with_network(self) -> bool:
        """Sync blockchain with network"""
        longest_chain = None
        max_length = len(self.blockchain.chain)

        # Query all peers
        for peer in self.peers:
            try:
                response = requests.get(f"{peer}/blocks", timeout=5)
                if response.status_code == 200:
                    data = response.json()
                    chain_length = data['total']

                    if chain_length > max_length:
                        # This chain is longer, get full chain
                        full_response = requests.get(
                            f"{peer}/blocks?limit={chain_length}",
                            timeout=10
                        )
                        if full_response.status_code == 200:
                            longest_chain = full_response.json()['blocks']
                            max_length = chain_length

            except Exception as e:
                print(f"Error syncing with {peer}: {e}")

        # Replace chain if we found a longer valid one
        if longest_chain and len(longest_chain) > len(self.blockchain.chain):
            # Validate new chain before replacing
            # (In production, implement full chain validation)
            print(f"Syncing blockchain... New length: {len(longest_chain)}")
            return True

        return False

    def run(self, debug=False):
        """Start the node"""
        self.start_time = time.time()

        print("=" * 60)
        print("AIXN BLOCKCHAIN NODE")
        print("=" * 60)
        print(f"Miner Address: {self.miner_address}")
        print(f"Listening on: http://{self.host}:{self.port}")
        print(f"Blockchain height: {len(self.blockchain.chain)}")
        print(f"Network difficulty: {self.blockchain.difficulty}")
        print("=" * 60)

        # Start auto-mining by default
        self.start_mining()

        # Run Flask app
        self.app.run(host=self.host, port=self.port, debug=debug, threaded=True)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='AIXN Blockchain Node')
    parser.add_argument('--port', type=int, default=8545, help='Port to listen on')
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind to')
    parser.add_argument('--miner', help='Miner wallet address')
    parser.add_argument('--peers', nargs='+', help='Peer node URLs')

    args = parser.parse_args()

    # Create and run node
    node = BlockchainNode(host=args.host, port=args.port, miner_address=args.miner)

    # Add peers if specified
    if args.peers:
        for peer in args.peers:
            node.add_peer(peer)

    # Start the node
    node.run()
